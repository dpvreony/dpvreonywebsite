@using DPVreony.Website.Features.Articles
@using NodaTime
@{
    var articleMetadata = new ArticleMetadataModel(
        ArticleStatus.Released,
        new Version(1, 0),
        new LocalDate(2021, 05, 31),
        new LocalDate(2021, 06, 18),
        new LocalDate(2021, 06, 18),
        new LocalDate(2021, 07, 18));
}
<div class="row">
    <div class="col-md-8">
        <h1>Designing Vetuviem.</h1>

        <h2>Introduction</h2>
        <p>Vetuviem is a Roslyn Source Generation toolkit on top of ReactiveUI aimed at empowering development teams by:</p>
        <ul>
            <li>Giving a mechanism to reduce the amount of boiler plate code being produced, by allowing some of the ReactiveUI specific logic to be hidden away.</li>
            <li>Allow the developer to think along the lines of standard behavior for controls by offering a way to produce re-usable binding logic through a class and\or function design pattern.</li>
            <li>Allow the developer to focus on what matters on the ViewModel</li>
            <li>Reduce the cognitive load by:
                <ul>
                    <li>Removing the risk of misusing 1 way or 2 way binding</li>
                    <li>Remove the need for the user to think about having to cater for Bind vs BindCommand</li>
                    <li>Offer a structure that allows for more work to be done potentially with Source Generators to reduce reflection and improve the build time developer experience.</li>
                </ul>
            </li>
        </ul>

        <h2>Where Vetuviem fits</h2>
        <p>Vetuviem acts as glue between the View and ViewModel in the MVVM pattern when using Codebehind binding in your XAML, you can think of it as MV2VM. The name comes from "V to VM", and is become a play on Latin (ve tu vi iem) which if you put in a translation tool and split correctly comes out as "You've force that day on".</p>
        <p>The View Binding Models have a tipping point for being useful in terms of scalable of sustainable development. This can equate to:</p>
        <ul>
            <li>How many controls you have that conform to a standard behaviour.</li>
            <li>How many properties you bind between the View and ViewModel on these controls.</li>
        </ul>
        <p>One of the quick time savers \ code reductions it allows is to write the control binding expression (i.e. vw => vw.TextBoxName) once, instead of for every binding line, as the library handles the individual control property expressions (vw => vw.TextBoxName.Text, vw.TextBoxName.Foreground, etc.) in the background.</p>

        <h2>Project phases</h2>
        <ol>
            <li>Producing a library that generates ViewBindingModels for each control in a standard library for a platform.</li>
            <li>Detailing how to use the generation with other control libraries.</li>
            <li>Detail further potential improvements for source generation.</li>
        </ol>

        <h2>Producing the ViewBindingModels</h2>
        <p>This first phase is the crux of the library. There are certain facts that underpin ReactiveUI binding.</p>
        <ol>
            <li>Each UI platform that is supported has a base class and\or interface for controls.</li>
            <li>If a UI platform supports Commands, that platform has a base class or interface.</li>
            <li>The core of ReactiveUI is agnostic as much as possible from these platform specific parts.</li>
            <li>There are essentially 3 types of bindings.
                <ol>
                    <li>Command Bindings</li>
                    <li>One-way Property Bindings (where one side of the relationship only supports reading - the read only part is typically a property on the control such as a "HasItems" indicator on a control that represents a collection of items)</li>
                    <li>Two-way Property Bindings (where there can be a bi-directional flow)</li>
                </ol>
            </li>
        </ol>

        <p>Roslyn source generators are a powerful addition to NET5. While previous concepts have existed for years, this is the first iteration to over natural support in the IDE and build chain for .NET. There are still some parts in the IDE support that need to mature but it will only be a matter of time with use and engagement of the community. The one snag is the lack of detailed documentation around Roslyn, luckily the Syntax Visualizer within Visual Studio is a handy tool to aid in making sense of the method calls you need to use, but it can be a bit of trial and error where progress goes through peaks and troughs.</p>

        <p>The process put together for this library uses the following concepts</p>
        <ul>
            <li>A UI platform (or subsequent libraries) will have libraries that are available via one of the following sources:
                <ol>
                    <li>Native platform support via the SDK target.</li>
                    <li>Package(s) available from NuGet</li>
                </ol>
            </li>
            <li>The build and Visual Studio project system will be responsible for driving the package availability.</li>
            <li>The Roslyn Source Generation Context makes the reference library available to consumers. It is possible for us to use platform specific logic to check the libraries are available, and for us to drive loading of additional references.</li>
            <li>We will scan each library of interest for classes that implement\inherit from the platforms core UI class \ interface.</li>
            <li>For each class (UI element) we match, we scan for public properties and define the type of binding as described above under ReactiveUI concepts.</li>
            <li>We will build an inheritance model to reduce duplicate code.</li>
            <li>We will generate a "bound" and "unbound" ViewBindingModel for each class. The unbound is to allow the flexibility in the generic inheritance design. The bound model is type specific model that removes one of the generic arguments to ensure that developers can utilize the control specific ViewBindingModel without having to deal with generic argument for the control.</li>
        </ul>

        <h3>Making Vetuviem usable with other libraries.</h3>
        <p></p>

        <h3>Future options for Vetuviem and source generation</h3>
        <p>Currently Vetuviem is a one step process where it generates binding logic for every property on a control. The apply binding logic does a null check on every property in the View Binding Model to then drive the actual binding. We could add a second step process that recognizes these bindings are fixed at compile time and removes the "not null then bind" check for properties that will never bind. In theory there is already enough knowledge from what exists in Vetuviem for the compiler \ IL merge tools to perform this on a build, but the source generator could also do this as a second step to make it completely clear during a build and the code would be visible. At this point this is an option but Vetuviem needs to prove its value first.</p>
        <p>Another piece is co-existing with the event binding that is offered by Pharmacist. There is currently having other work done on a source generator level to make the event logic not be tied to specific ReactiveUI (and specific UI platform) versions. This interaction with Vetuviem was left out of scope to allow focused proof of value.</p>

        <h2>References</h2>
        <p>TODO</p>
    </div>
    <div class="col-md-4">
        @await Html.PartialAsync("_article_metadatasummary", articleMetadata)
    </div>
</div>
